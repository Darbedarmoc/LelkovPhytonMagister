Сразу должен сказать, что я впервые работаю в питоне, в моем прошлом вузе мы изучали все, кроме него. В целом я многое на уровне алгоритмизации, но не в коде. 
Потому извиняюсь, если будет прям что то из ряда вон выходяшего х) 
Например подсказки у кода, чтобы не забыть, что за что отвечает и мне было проще думать.. Оно не ГПТшное, а то, как я это понимаю.

Есть следующий код для автоматического дифференцирования, в котором используются особенности системы типов языка Python:

from dataclasses import dataclass       #Импорту модулей (декоратор), создает __init__ - своеобразный ввод данных, типо ''номер.имя.возраст.местоработы''
                                        # (вписывается в класс, работает как функция, формула, красивый вывод) 
                                        # __repr__ (В целом тоже самое, но показывает с ''номер.имя.возраст.местоработы'', нужен для лучшего понимания происходящего разработчику)

from typing import Union, Callable      #Аннотация типов, вспомогалка кода, подсказывает код, предлагает дописать за человека. 
                                        #Union - позволяет взять какие то конкретные типы данных ''номер, возраст'', также функция. 
                                        #Callable - позволяет переводить одни типы в другие.. например из int -> str

from numbers import Number              #Числовой тип, позволяет работать с int и float

@dataclass
class Dual:                             #с помощью Union, мы объеденяем два значения (функции и производной), теперь мы можем создавать объект Dual, который генерирует метод __init__
    value: float
    d: float

    def __add__(self, other: Union["Dual", Number]) -> "Dual":  #Здесь задаем значение other 
                                                                # __add__ это сложение (''__'' используются ради того, чтобы выполнялось именно значение и не путалось ни с каким именем в файле) 
                                                                #self (своеобразное указание на атрибут) используется внутри метода, чтобы указать, что мы работаем с атрибутами и методами текущего объекта
         match other:                               # Проверить, подходит ли other к dual
            case Dual(o_value, o_d):
                return Dual(self.value + o_value, self.d + o_d) #Если other будет равен union, то происходит сложение значенией функции и прозводных, ИНАЧЕ идет сложение только значений (производная не меняется)
            case Number():
                return Dual(float(other) + self.value, self.d)

    def __mul__(self, other: Union["Dual", Number]) -> "Dual": #Также задается значение other, что будет работать только в этом классе | __mul__ это умножение
         match other:
            case Dual(o_value, o_d):
                return Dual(self.value * o_value, self.value * o_d + self.d * o_value) #Если other подходит к Dual, то формула произведения производных  "(u(x)⋅v(x))=u′v+uv"
            case Number():
                return Dual(float(other) * self.value, float(other) * self.d)          #ИНАЧЕ просто умножение значений 

    __rmul__ = __mul__  # https://docs.python.org/3/reference/datamodel.html#object.__mul__   | Меняют местами значения числа и Dual
    __radd__ = __add__  # https://docs.python.org/3/reference/datamodel.html#object.__radd__  | Как я понимаю, в случаях, если Dual будет стоять спарва, то чтобы стояло слева и в коде не было сбоя
 

def diff(func: Callable[[float], float]) -> Callable[[float], float]:     # diff в данном случае создает функцию, для работы над функцией | По итогу входное значение x становится значением Dual с производной 1
    return lambda x: func(Dual(x, 1.0)).d                                 # Присваивает значение 1 к значению d

    
Поддерживаются две операции - сложение и умножение. Применить можно так:

# Функция, которую будем дифференцировать
def f(x: float) -> float:
    return 5 * x * x + 2 * x + 2

f_diff = diff(f)

# значение производной в точке x = 2
f_diff(2)
22.0


###########################____________ЗАДАНИЕ 1.1____________###########################


