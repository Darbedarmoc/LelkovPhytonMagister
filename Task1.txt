Сразу должен сказать, что я впервые работаю в питоне, в моем прошлом вузе мы изучали все, кроме него. В целом я многое на уровне алгоритмизации, но не в коде. 
Потому извиняюсь, если будет прям что то из ряда вон выходяшего х) 
Например подсказки у кода, чтобы не забыть, что за что отвечает и мне было проще думать.. Оно не ГПТшное, а то, как я это понимаю.
Еще изначально пытался сделать красивенько как у вас в работе, но запутался в кавычках, скобках, / \ палочках и...  в итоге тхт с кодом... Так что где то могут быть аномалии типа /n" ... Извиняюсь

Есть следующий код для автоматического дифференцирования, в котором используются особенности системы типов языка Python:

from dataclasses import dataclass       #Импорту модулей (декоратор), создает __init__ - своеобразный ввод данных, типо ''номер.имя.возраст.местоработы''
                                        # (вписывается в класс, работает как функция, формула, красивый вывод) 
                                        # __repr__ (В целом тоже самое, но показывает с ''номер.имя.возраст.местоработы'', нужен для лучшего понимания происходящего разработчику)

from typing import Union, Callable      #Аннотация типов, вспомогалка кода, подсказывает код, предлагает дописать за человека. 
                                        #Union - позволяет взять какие то конкретные типы данных ''номер, возраст'', также функция. 
                                        #Callable - позволяет переводить одни типы в другие.. например из int -> str

from numbers import Number              #Числовой тип, позволяет работать с int и float

@dataclass
class Dual:                             #с помощью Union, мы объеденяем два значения (функции и производной), теперь мы можем создавать объект Dual, который генерирует метод __init__
    value: float
    d: float

    def __add__(self, other: Union["Dual", Number]) -> "Dual":  #Здесь задаем значение other 
                                                                # __add__ это сложение (''__'' используются ради того, чтобы выполнялось именно значение и не путалось ни с каким именем в файле) 
                                                                #self (своеобразное указание на атрибут) используется внутри метода, чтобы указать, что мы работаем с атрибутами и методами текущего объекта
         match other:                               # Проверить, подходит ли other к dual
            case Dual(o_value, o_d):
                return Dual(self.value + o_value, self.d + o_d) #Если other будет равен union, то происходит сложение значенией функции и прозводных, ИНАЧЕ идет сложение только значений (производная не меняется)
            case Number():
                return Dual(float(other) + self.value, self.d)

    def __mul__(self, other: Union["Dual", Number]) -> "Dual": #Также задается значение other, что будет работать только в этом классе | __mul__ это умножение
         match other:
            case Dual(o_value, o_d):
                return Dual(self.value * o_value, self.value * o_d + self.d * o_value) #Если other подходит к Dual, то формула произведения производных  "(u(x)⋅v(x))=u′v+uv"
            case Number():
                return Dual(float(other) * self.value, float(other) * self.d)          #ИНАЧЕ просто умножение значений 

    __rmul__ = __mul__  # https://docs.python.org/3/reference/datamodel.html#object.__mul__   | Меняют местами значения числа и Dual
    __radd__ = __add__  # https://docs.python.org/3/reference/datamodel.html#object.__radd__  | Как я понимаю, в случаях, если Dual будет стоять спарва, то чтобы стояло слева и в коде не было сбоя
 

def diff(func: Callable[[float], float]) -> Callable[[float], float]:     # diff в данном случае создает функцию, для работы над функцией | По итогу входное значение x становится значением Dual с производной 1
    return lambda x: func(Dual(x, 1.0)).d                                 # Присваивает значение 1 к значению d

    
Поддерживаются две операции - сложение и умножение. Применить можно так:

# Функция, которую будем дифференцировать
def f(x: float) -> float:
    return 5 * x * x + 2 * x + 2

f_diff = diff(f)

# значение производной в точке x = 2
f_diff(2)
22.0


###########################____________ЗАДАНИЕ 1.1____________###########################

Какие недостатки вы видите в данной реализации? Реализуйте поддержку (полностью самостоятельно или модифицируя приведенный код):
-  унарных операций
-  деления
- возведения в степень
Каким образом можно проверить корректность решения? Реализуйте достаточный, по вашему мнению, набор тестов.

# Честно не совсем понимаю, какие еще есть недостатки, кроме тех, что приведены выше (унарные операции, деление, возведение в степень), но думаю можно еще добавить вычитание для полной коллекции ._. с него и начнем

def __sub__(self, other: Union["Dual", Number]) -> "Dual":            # __sub__ служит минусом
  return self + (-other)
######################################################################################################################################################
def __neg__(self) -> "Dual":                                          # __neg__ делает число с знаком - 
  return Dual(-self.value, -self.d)
######################################################################################################################################################
def __truediv__(self, other: Union[\"Dual"\, Number]) -> "Dual":      # __truediv__ четкое деление до сотых 
  match other:
    case Dual(o_value, o_d):
     return Dual(self.value / o_value, (self.d * o_value - self.value * o_d) / (o_value ** 2))          # формула производного деления (u′(x)v(x)−u(x)v′(x)) / v′(x)^2
    case Number():
     return Dual(self.value / float(other), self.d / float(other))                      # иначе просто деление значений  
######################################################################################################################################################
def __pow__(self, power: Union[\"Dual"\, Number]) -> "Dual":                            # __pow__ возведение в степень числа 
  match power:                                                                    #тут мы используем другую переменную, т.к. она будет переумножаться и иметь своеобразную силу (но в целом можно использовать и other)
    case Dual(p_value, p_d):
  return Dual(self.value ** p_value, self.value ** (p_value - 1) * (p_d * self.value * p_value + self.d * p_value))         # формула возведения в степень производных чисел (u′(x)v(x)−u(x)v′(x)) / v′(x)^2
    case Number():
  return Dual(self.value ** float(power), self.d * float(power) * self.value ** (float(power) - 1))                         # иначе просто возведения в степень числа значения 
######################################################################################################################################################
# Дальше как и в изначально примере отражаем числа
 __rsub__ = __sub__ 
 __rtruediv__ = __truediv__ 
 __rpow__ = __pow__
    " \n",
    " \n",
    "# Для тестирования я подготовил следующие примеры"
    " \n",
    " \n",
    "   def test_add():  # Сложение   \n", 
    "   def f(x: float) -> float:     \n",
    "    return x + 7\n",
    " assert diff(f)(5) == 1     \n",
    " \n",
    " \n",
    "   def test_sub():   # Вычитание  \n", 
    "   def f(x: float) -> float:     \n",
    "    return x - 7\n",
    " assert diff(f)(5) == 1     \n",
    " \n",
       " \n",
    "   def test_neg():  # отрицание   \n", 
    "   def f(x: float) -> float:     \n",
    "    return -x\n",
    " assert diff(f)(5) == 1     \n",
    " \n",
    " \n",
    "   def test_mul():  # умножение   \n", 
    "   def f(x: float) -> float:     \n",
    "    return x * 7\n",
    " assert diff(f)(5) == 1     \n",
    " \n",
    " \n",
    "   def test_truediv():   # Деление  \n", 
    "   def f(x: float) -> float:     \n",
    "    return x / 7\n",
    " assert diff(f)(5) == 1     \n",
    " \n",
    "   def test_pow():  # Возведение в степень   \n", 
    "   def f(x: float) -> float:     \n",
    "    return x ** 7\n",
    " assert diff(f)(5) == 1     \n",
    " \n",
    "# Для запускай тестов надо писать: "
      " \n",
    "test_add() \n",
    "test_sub() \n",
    "test_neg() \n",
    "test_mul() \n",
    "test_truediv() \n",
    "test_pow() \n",
    "print(\"+"\) \n",
    "#На этом задание 1.1. подходит к концу, по коду оно стоит после умножения"
